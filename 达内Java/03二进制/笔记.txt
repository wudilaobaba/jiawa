2进制
  01.计算机内存中所有的数据都是二进制的
  02.计算机接受到10进制的时候，利用编程语言提供的算法(方法)转化为2进制进行计算
  03.计算机在输出时，会利用编程语言将2进制转为10进制字符串输出
  04.人可以利用编程语言顺利的使用10进制与计算机进行交互
  05.32位的2进制是32位数，前面为0会省略
什么是二进制
  逢2进1的计数规则                   十进制                              16进制
  数字： 0 1                         数字：0 1 2 3 4 5 6 7 8 9           数字:   0 1 2 3 4 5 6 7 8 9  a b c d e f
  权: ... 64 32 16 8 4 2 1          权... 1000 100 10 1                  权：   ... 16*16  16  1
  基数:10                            基数：2                             基数：  16
什么是16进制
  逢16进1的计数规则
  计算机行业利用16进制作为二进制的缩写(简写)--->目的就是写二进制方便
    01.利用16进制可以将二进制从后向前每4位缩写为1位16进制(16进制的理解.png)
    02.工作中只要给一个数用二进制赋值，那么都写成16进制（32位的16进制是8位数，前面为0会省略）数字1其实就是：0x00000001
补码(为了搞定负数)  --->就是为了将n位的二进制数分一半当负数，这个分法就是补码，巧合的是出现了互补对称现象，所以就叫补码
  就是计算机处理负数(有符号数)的一种方案，其原理是将固定位数的2进制分一半作为负数的方案
  ‘分一半’的理解：(先理解----->n位数的二进制数共有2的n次方个)
    n位数的二进制数共有2的n次方个,将n位数的二进制数分一半，就有2^n/2个负数，2^n/2个正数(含0)
    是在有固定位数了的2进制数的基础上进行分一半
    自己推演2位和3位的二进制数的分一半负数，推演完成后得到结论:
      int类型n位的负数,不满32位则前面补32-n个1; ******** +
      int类型n位的正数,不满32位则前面补32-n个0; ******** -
      byte类型n位的负数,不满8位则前面补8-n个1; ********* +
      byte类型n位的正数,不满8位则前面补8-n个0; ********* -
    byte类型：1个字节/占8位，可以表示所有的8位数的二进制数,即2的8次方个,共256个。分一半做负数，那么范围就是-128~127之间(0算正数，所以各一半)
    int类型：4个字节/占32位，可以表示所有的32位数的二进制数,即2的32次方个,共42亿个。分一半做负数，..... (0算正数，所以各一半)
    规律：
      n位2进制的最大值：1个0+(n-1个1)
      n位2进制的最小值：1个1+(n-1个0)
      n位2进制的-1：n个1
      int类型最小值对应的16进制：0x8+(32/4-1)个0   可推测Long型
      int类型最大值对应的16进制：0x7+(32/4-1)个f   可推测Long型
      n位数的二进制的-1为n个1 ; n位数的16进制的-1为0x+(n/4个f)

  取反加一能对称,该结论对n位数的二进制数的最小值不成立(还是最小值本身)，n位数的二进制数的最小值取反以后得到n位二进制数的最大值(反之成立)：看图 取反加一.png    0与-1永远是**位置**对称的
    意思就是一个二进制数想要找到它的对称数(如:4的对称数是-4)(4的二进制为0100)，就要1变0,0变1-->这是取反，得到了1011--->-5,再加一就是-4,即1100
    （n为正数，-n与n-1互为二进制的取反(1变0,0变1)）
2进制运算与经典面试题

显示n在内存中实际的2进制形式：Integer.toBinaryString(n) //n在内存中就是2进制的



补充：
01.给一个二进制的正数，自己还原为10进制：如11010110
  1   1   0   1   0   1   1   0
 128  64  32  16  8   4   2   1
 将所有1对应的数加起来就是11010110转为10进制的数--->214

02.给一个二进制的数，自己还原为10进制：如--> 11111111 11111111 11111111 01001011
  第一步：判断是正数还是负数，若不满8/16/64位，或满了4/8/16/32/64位且第一位是0，则必然是正数，那么按照上面的'补充01'来还原
         否则必然是负数，且前面全是1。
  第二步：还原负数，先看这个负的二进制的权，如--> 11111111 11111111 11111111 0  1  0   0  1011
                                                                         128   32  16  4  加一起为180，即比-1(32个1)小了180，那自然就是-181了

03.其实int型为4个字节占32位，所以转为二进制的时候默认为32位数  1其实就是 00000000000000000000000000000001

04.以后每天算10个二进制转十进制，使用binary.day01/Demo01.java来出题

05.
16进制是对二进制的每4位的缩写
32进制是对二进制的每5位的缩写   X
64进制是对二进制的每6位的缩写   X
128进制是对二进制的每7位的缩写  X
256进制是对二进制的每8位的缩写  X

06.职业程序员在写2进制的时候，是用16进制在写的

07. 互补对称的应用，快速计算一个负数的补码  如：计算-100的补码
  step01.找到对应正数的补码               100的补码：       00000000 00000000 00000000 01100100
  step02.对整数的补码进行取反：           100的补码进行取反：11111111 11111111 11111111 10011011
  step03.取反后+1                        取反后+1 ：       11111111 11111111 11111111 10011100  就是-100的补码
  以上找-100的补码建议使用-1减99的方法***

08.
11111111 11111111 11111111 11111111  扣下去为0的权加一起若为n， 那么，这个数就是比-1小n的负数：如
11111111 11111111 11111111 11000101  扣下去为0的权加一起若为58，那么，这个数就是比-1小58的负数，即-59

09.大到小的强转(将高位去掉)：
int a = (byte)(130);
00000000 00000000 00000000 10000010  int类型的130
转为byte类型，将高位去掉
10000010  byte类型的130   根据"补充02"的总结可以断定该数为负数，在根据"扣除"的算法可以算出该数字的十进制为-126

10.计算机进行返回结果前，都是将数字转成了2进制后，先进行了一次2进制的运算！！！！！！！！！！！！！！！重要！！！！！！！！！！！！！！

综上：掌握了
  01.正数 10进制与2进制的互转
  02.负数 10进制与2进制的互转
    10->2 取反加一 或 -1往下扣

二进制的计算：
01.移位计算>>> >> <<
<<左移位计算
  计算规则：将二进制数整体向左移动一位，高位自动溢出，低位补0
    n =        00000100 10010001 00111111 01010101
    m = n<<1   0000100 10010001 00111111 010101010
    m = n<<2   000100 10010001 00111111 0101010100
  移位计算的数学意义
  复习 10进制移动小数点计算
  如：                1242213.
  小数点向右移动一次   12422130.  数字扩大10倍
  如果看中小数点不动，则数字向左移动,每移动一次，数字扩大10倍
  推广：10进制规律在2进制的情况下，依然存在
       如果看中小数点不动，则数字向左移动,每移动一次，数字扩大2倍
       10进制规律在n进制的情况下，依然存在
       如果看中小数点不动，则数字向左移动,每移动一次，数字扩大n倍
  结论：计算机是进行二进制运算的，所以根据二进制得出的结论为int n = 10; int m=n<<i;  m = n*2^i
>>数学移位计算
  规则：
    当高位(符号位)为1的时候，高位补1，保持负数符号，低位舍弃
    当高位(符号位)为0的时候，高位补0，低位舍弃
    计算意义：每移动一次，数字除2，余数舍弃，向小方向取整 -->5/2就是2  -5/2就是-3
  //符号位就是从二进制上看的正负，为1就是负数，为0就是正数
>>> 在>>的基础上，不管正数负数，高位永远补0，单纯用移位，如拆分数字  负数就变正数了

经典面试题：
01.System.out.println(~8+1)//取反加一
02.
  int n = 100;
  byte m = (byte)(n+46);
  m = ?
  n -->  00000000 00000000 00000000 01100100
  46->   00000000 00000000 00000000 00101110
n+46-->  00000000 00000000 00000000 10010010
(byte)(n+46)-->int强转byte要将高位去掉后得到： 10010010 ->是个负数---> -110
03.优化计算 n*8为（n<<3）//移位的效率比乘法高  除法不需要优化！！！！！
